"use client"

import { useEffect, useState } from "react"
import { useRouter } from "next/navigation"
// --- AI BUILDER: Ajout des icônes nécessaires ---
import { Globe, ArrowUp, Copy, Download, LogOut, Bot, User, Eye, Send } from "lucide-react"
import { motion, useReducedMotion } from "framer-motion"
import { Bodoni_Moda } from "next/font/google"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription,
  DialogFooter,
} from "@/components/ui/dialog"
import { Button } from "@/components/ui/button"
import { Label } from "@/components/ui/label"
import { Switch } from "@/components/ui/switch"
import { type auth, onAuth, logout } from "@/lib/firebase"
import { DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem } from "@/components/ui/dropdown-menu"
import { Avatar, AvatarFallback } from "@/components/ui/avatar"
import { Client, Databases } from "appwrite"
import { Progress } from "@/components/ui/progress"
// --- AI BUILDER: Import de la librairie demandée (supprimé car fetch est natif) ---
// import { GoogleGenerativeAI, Part, GenerationConfig, Tool } from "@google/generative-ai";

const bodoni = Bodoni_Moda({ subsets: ["latin"], display: "swap" })

type AnimationFile = {
  url: string
  content: string
  type: "css" | "js"
  isAnimation: boolean
  library?: string
  confidence: number
}

type Result = {
  title: string
  description: string
  techGuesses: string[]
  internalLinks: number
  externalLinks: number
  images: string[]
  stylesheets: number
  openGraphTags: number
  fullHTML: string
  cleanedHTML: string
  fullCSS: string
  fullJS: string
  animationCSS: string
  animationJS: string
  baseURL: string
  animationFiles: AnimationFile[]
  requiredCdnUrls: string[]
}

const ResultItem = ({ label, value }: { label: string; value: string | number }) => (
  <div className="flex justify-between items-center py-4 border-b border-gray-800/50">
    <p className="text-gray-400">{label}</p>
    <p className="text-[#e4e4e4] text-right font-medium truncate pl-4">{value}</p>
  </div>
)

function CircularText({ size = 140 }: { size?: number }) {
  const prefersReduced = useReducedMotion()
  const radius = size / 2 - 8
  const text = " STUDIO • STUDIO • STUDIO • STUDIO • STUDIO • STUDIO • STUDIO • STUDIO • STUDIO • STUDIO •"
  return (
    <div className="mx-auto mb-6 flex items-center justify-center">
      <motion.svg
        width={size}
        height={size}
        viewBox={`0 0 ${size} ${size}`}
        className="text-black"
        aria-hidden="true"
        animate={prefersReduced ? undefined : { rotate: 360 }}
        transition={prefersReduced ? undefined : { repeat: Number.POSITIVE_INFINITY, duration: 14, ease: "linear" }}
        style={{ willChange: "transform" }}
      >
        <defs>
          <path
            id="circlePath"
            d={`M ${size / 2},${size / 2} m -${radius},0 a ${radius},${radius} 0 1,1 ${radius * 2},0 a ${radius},${radius} 0 1,1 -${radius * 2},0`}
          />
        </defs>
        <text fill="currentColor" fontSize="12" letterSpacing="2" className={`${bodoni.className} tracking-widest`}>
          <textPath href="#circlePath">{text}</textPath>
        </text>
      </motion.svg>
    </div>
  )
}

function LogoMarquee() {
  const prefersReduced = useReducedMotion()
  const logos = [
    "/images/logos/windsurf-text.svg",
    "/images/logos/v0.svg",
    "/images/logos/trae-text.svg",
    "/images/logos/replit-text.svg",
    "/images/logos/cursor-text.svg",
  ]
  const repeated = [...logos, ...logos, ...logos]
  return (
    <div className="relative my-10">
      <div className="pointer-events-none absolute inset-y-0 left-0 w-16 bg-gradient-to-r from-white to-transparent" />
      <div className="pointer-events-none absolute inset-y-0 right-0 w-16 bg-gradient-to-l from-white to-transparent" />
      <div className="overflow-hidden">
        <motion.div
          className="flex gap-10 items-center"
          animate={prefersReduced ? undefined : { x: ["0%", "-50%"] }}
          transition={prefersReduced ? undefined : { duration: 30, repeat: Number.POSITIVE_INFINITY, ease: "linear" }}
          style={{ willChange: "transform" }}
        >
          {[...repeated, ...repeated].map((src, idx) => (
            <img
              key={`${src}-${idx}`}
              src={src || "/placeholder.svg"}
              alt="logo"
              className="h-6 sm:h-8 object-contain"
            />
          ))}
        </motion.div>
      </div>
    </div>
  )
}

type FrameworkKey = "next" | "remix" | "astro" | "vite-react" | "sveltekit" | "vue-vite" | "nuxt" | "html"
const frameworkLabel: Record<FrameworkKey, string> = { next: "Next.js (App Router, TSX)", remix: "Remix (TSX)", astro: "Astro (.astro)", "vite-react": "Vite (React, JSX)", sveltekit: "SvelteKit (+page.svelte)", "vue-vite": "Vue (Vite, SFC)", nuxt: "Nuxt (pages/preview.vue)", html: "HTML + CSS + JS (combined)" }

export default function SiteInspector() {
  const router = useRouter()

  const [isAuthReady, setIsAuthReady] = useState(false)
  const [user, setUser] = useState<ReturnType<(typeof auth)["currentUser"]> | null>(null)
  const [subscription, setSubscription] = useState<any>(null)
  const [subscriptionLoading, setSubscriptionLoading] = useState(false)
  const [url, setUrl] = useState("")
  const [result, setResult] = useState<Result | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)
  const [copyStatus, setCopyStatus] = useState<{ id: string; message: string } | null>(null)
  const [showExportModal, setShowExportModal] = useState(false)
  const [selectedFramework, setSelectedFramework] = useState<FrameworkKey>("next")
  const [generatedFilename, setGeneratedFilename] = useState<string>("")
  const [generatedCode, setGeneratedCode] = useState<string>("")
  const [showCodePreview, setShowCodePreview] = useState<boolean>(false)
  const [analysisMessage, setAnalysisMessage] = useState("")

  const [isAiResponding, setIsAiResponding] = useState(false);
  const [aiGeneratedFiles, setAiGeneratedFiles] = useState({ html: '', css: '', js: '' });
  const [activeFile, setActiveFile] = useState<'html' | 'css' | 'js'>('html');
  const [aiStudioInitiated, setAiStudioInitiated] = useState(false);
  const [aiMessage, setAiMessage] = useState("");

  useEffect(() => {
    const unsub = onAuth(async (u) => { setUser(u); setIsAuthReady(true); if (u) { loadSubscription(u.uid); } else { setSubscription(null); } });
    return () => unsub();
  }, []);

  const loadSubscription = async (userId: string) => {
    setSubscriptionLoading(true);
    try {
      const client = new Client().setEndpoint("https://fra.cloud.appwrite.io/v1").setProject("68802a5d00297352e520");
      const databases = new Databases(client);
      const response = await databases.getDocument("boodupy-3000", "subscription-300", userId);
      setSubscription(response);
    } catch (error) { console.error("Error loading subscription:", error); setSubscription(null); } 
    finally { setSubscriptionLoading(false); }
  };

  const isSubscriptionValid = () => { if (!subscription) return false; const now = new Date(); const expiration = new Date(subscription.expirationDate); return now < expiration; };
  const getSubscriptionProgress = () => { if (!subscription) return 0; const now = new Date(); const expiration = new Date(subscription.expirationDate); const created = new Date(subscription.$createdAt); const total = expiration.getTime() - created.getTime(); const elapsed = now.getTime() - created.getTime(); return Math.max(0, Math.min(100, (elapsed / total) * 100)); };
  const getTimeRemaining = () => { if (!subscription) return ""; const now = new Date(); const expiration = new Date(subscription.expirationDate); const diff = expiration.getTime() - now.getTime(); if (diff <= 0) return "Expired"; const minutes = Math.floor(diff / (1000 * 60)); const seconds = Math.floor((diff % (1000 * 60)) / 1000); if (minutes > 0) { return `${minutes}m ${seconds}s remaining`; } return `${seconds}s remaining`; };
  const proposalUrlsSection1 = ["cursor.com", "framer.com", "lovable.dev", "linear.app", "notion.com"];
  const proposalUrlsSection2 = ["playerzero.ai", "apresentforce.com", "portfolite.framer.website"];
  const proposalUrlImages: Record<string, string> = { "playerzero.ai": "https://fra.cloud.appwrite.io/v1/storage/buckets/68968fe8001266b9f411/files/68969cd6000b7adb25e0/view?project=68802a5d00297352e520&mode=admin", "apresentforce.com": "https://fra.cloud.appwrite.io/v1/storage/buckets/68968fe8001266b9f411/files/68969d45000bcf13ad68/view?project=68802a5d00297352e520&mode=admin", "portfolite.framer.website": "https://fra.cloud.appwrite.io/v1/storage/buckets/68968fe8001266b9f411/files/689e40cd000ed8efd26d/view?project=68802a5d00297352e520&mode=admin" };
  const createDownloadLink = (content: string, filename: string, mimeType: string) => { const blob = new Blob([content], { type: mimeType }); const url = URL.createObjectURL(blob); const a = document.createElement("a"); a.href = url; a.download = filename; document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url); };
  const copyToClipboard = async (text: string, id: string) => { try { await navigator.clipboard.writeText(text); setCopyStatus({ id, message: "Copied! ✅" }); setTimeout(() => setCopyStatus(null), 2000); } catch { setCopyStatus({ id, message: "Copy Failed ⌐" }); setTimeout(() => setCopyStatus(null), 2000); } };
  const fetchWithRetry = async (url: string, maxAttempts = 15, delay = 1000): Promise<{ success: boolean; content: string; error?: string }> => { for (let attempt = 1; attempt <= maxAttempts; attempt++) { try { const proxyUrl = `https://api.allorigins.win/get?url=${encodeURIComponent(url)}`; const response = await fetch(proxyUrl); if (!response.ok) throw new Error(`Network response was not ok (status: ${response.status})`); const data = await response.json(); if (!data.contents) throw new Error(`No content received from proxy`); return { success: true, content: data.contents }; } catch (error) { const errorMsg = error instanceof Error ? error.message : String(error); if (attempt < maxAttempts) { await new Promise((resolve) => setTimeout(resolve, delay)); } else { return { success: false, content: "", error: errorMsg }; } } } return { success: false, content: "", error: "Should not reach here" }; };
  const getLibraryCDN = (library: string): string[] => { const cdnMap: { [key: string]: string[] } = { GSAP: ["https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js", "https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"], "Three.js": ["https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"], }; return cdnMap[library] || []; };
  const detectAnimationLibrary = (url: string, content: string): { isAnimation: boolean; library?: string; confidence: number } => { const urlLower = url.toLowerCase(); const contentLower = content.toLowerCase(); const blacklist = ["googletagmanager", "google-analytics", "gtag"]; if (blacklist.some((item) => urlLower.includes(item))) { return { isAnimation: false, confidence: 0 }; } const libraries = [{ name: "GSAP", patterns: [{ pattern: /gsap|tweenmax/gi, weight: 90 }] }]; let bestMatch = { library: "", confidence: 0 }; for (const lib of libraries) { let totalScore = 0, matchCount = 0; for (const { pattern, weight } of lib.patterns) { const matches = (urlLower + " " + contentLower).match(pattern); if (matches) { totalScore += weight * matches.length; matchCount++; } } if (matchCount > 0) { const confidence = Math.min(100, totalScore / matchCount); if (confidence > bestMatch.confidence) bestMatch = { library: lib.name, confidence }; } } return { isAnimation: bestMatch.confidence > 60, library: bestMatch.library || undefined, confidence: bestMatch.confidence }; };
  
  const analyzeSite = async (urlToAnalyze = url) => {
    if (!urlToAnalyze) return;
    setLoading(true);
    setError(null);
    setResult(null);
    setCopyStatus(null);
    setAiStudioInitiated(false);
    setAiMessage("");
    setAiGeneratedFiles({ html: '', css: '', js: '' });

    try {
        let fullUrl = urlToAnalyze;
        if (!/^https?:\/\//i.test(fullUrl)) fullUrl = "https://" + fullUrl;
        const response = await fetch(`https://api.allorigins.win/get?url=${encodeURIComponent(fullUrl)}`);
        if (!response.ok) throw new Error(`La requête a échoué avec le statut : ${response.status}`);
        const data = await response.json();
        if (!data.contents) throw new Error("Aucun contenu reçu du proxy.");
        const html = data.contents;
        const parser = new DOMParser();
        const doc = parser.parseFromString(html, "text/html");
        const baseURL = new URL(fullUrl).origin;

        const title = doc.querySelector("title")?.textContent || "Aucun titre trouvé";
        const description = doc.querySelector('meta[name="description"]')?.getAttribute("content") || "Non trouvé";
        const stylesheetLinks = Array.from(doc.querySelectorAll('link[rel="stylesheet"]')).map(link => link.getAttribute("href")).filter(Boolean) as string[];
        
        let fullCSS = "";
        for (const href of stylesheetLinks) {
            const fullHref = new URL(href, baseURL).href;
            const fetchResult = await fetchWithRetry(fullHref);
            if (fetchResult.success) fullCSS += `/* Source: ${fullHref} */\n${fetchResult.content}\n\n`;
        }
        fullCSS += Array.from(doc.querySelectorAll("style")).map(el => el.textContent || "").join("\n\n");

        let fullJS = "";
        for (const script of Array.from(doc.querySelectorAll("script"))) {
            if (script.src) {
                const fullSrc = new URL(script.src, baseURL).href;
                const fetchResult = await fetchWithRetry(fullSrc);
                if (fetchResult.success) fullJS += `// Source: ${fullSrc}\n${fetchResult.content}\n\n`;
            } else {
                fullJS += `// Script en ligne\n${script.textContent || ""}\n\n`;
            }
        }
        
        const finalFullHTML = doc.body.outerHTML;
        const docCloneForPrompt = parser.parseFromString(html, "text/html");
        docCloneForPrompt.querySelectorAll('script, link, style, noscript, comment').forEach(el => el.remove());
        const promptOptimizedHTML = docCloneForPrompt.body.innerHTML;

        setResult({
            title, description, fullHTML: finalFullHTML, fullCSS, fullJS,
            cleanedHTML: promptOptimizedHTML, animationCSS: "/* TODO: Extraire le CSS d'animation */", animationJS: "// TODO: Extraire le JS d'animation",
            baseURL, techGuesses: [], internalLinks: 0, externalLinks: 0, images: [], stylesheets: 0, openGraphTags: 0, animationFiles: [], requiredCdnUrls: [],
        });

    } catch (err) {
        setError(err instanceof Error ? err.message : "Une erreur inconnue est survenue lors de l'analyse.");
    } finally {
        setLoading(false);
    }
  };

  const handleAnalyzeClick = () => { if (!user) { router.push("/signup"); return; } if (!isSubscriptionValid()) { router.push("/subscription"); return; } analyzeSite(); };
  const handleProposalClick = (proposalUrl: string) => { if (!user) { router.push("/signup"); return; } if (!isSubscriptionValid()) { router.push("/subscription"); return; } setUrl(proposalUrl); analyzeSite(proposalUrl); };
  const buildAdvancedPrompt = (): string => { if (!result) return ""; const HTML = result.cleanedHTML; return `HTML:\n${HTML}`; };
  const handleCopyPrompt = () => { if (!result) return; const prompt = buildAdvancedPrompt(); if (!prompt) return; copyToClipboard(prompt, "prompt"); };
  const handleDownloadPrompt = () => { if (!result) return; const prompt = buildAdvancedPrompt(); if (!prompt) return; createDownloadLink(prompt, "prompt.txt", "text/plain"); };
  const escTpl = (s: string) => s.replace(/`/g, "\\`").replace(/\$\{/g, "\\${");
  const gen = (fw: FrameworkKey) => { if (!result) return { filename: "", code: "" }; const HTML = escTpl(result.fullHTML); const CSS = escTpl(result.fullCSS); const JS = escTpl(result.fullJS); switch (fw) { default: return { filename: "index.html", code: `...` }; } };
  useEffect(() => { if (!result) return; const { filename, code } = gen(selectedFramework); setGeneratedFilename(filename); setGeneratedCode(code); }, [selectedFramework, result]);
  const createOptimizedPreview = () => { if (!result) return ""; return `<!DOCTYPE html><html><head><base href="${result.baseURL}"><style>${result.fullCSS}</style></head>${result.fullHTML}<script>${result.fullJS}</script></html>`; };
  const createReducedPreview = () => { if (!result) return ""; return `<!DOCTYPE html><html><head><base href="${result.baseURL}"><style>${result.animationCSS}</style></head>${result.fullHTML}<script>${result.animationJS}</script></html>`; };
  const HeaderAction = () => { if (!isAuthReady) return null; if (user) { const email = user.email || "user"; const fallback = email.slice(0, 2).toUpperCase(); return (<DropdownMenu><DropdownMenuTrigger asChild><Button variant="outline" className="h-[32px] rounded-[13px] bg-transparent"><Avatar className="h-6 w-6 mr-2"><AvatarFallback>{fallback}</AvatarFallback></Avatar>{email}</Button></DropdownMenuTrigger><DropdownMenuContent align="end" className="w-64">{subscription && (<div className="p-3 border-b"><div className="text-sm font-medium mb-2">{subscription.subscriptionType === "trial" ? "Free Trial" : "$2.99/month"}</div><div className="text-xs text-gray-600 mb-2">{getTimeRemaining()}</div><Progress value={getSubscriptionProgress()} className="h-2" /></div>)}<DropdownMenuItem onClick={async () => { await logout(); router.replace("/"); }}><LogOut className="h-4 w-4 mr-2" />Sign out</DropdownMenuItem></DropdownMenuContent></DropdownMenu>); } return <a href="/signup" className="h-[32px] w-auto px-5 text-sm flex items-center justify-center rounded-[13px] bg-black text-white font-semibold transition-opacity hover:opacity-90">Sign up</a>; };
  const onInputFocus = () => { if (!user) { router.push("/signup") } }

  const buildInitialPromptForAI = (): string => {
      if (!result) return "";
      const HTML = result.cleanedHTML;
      const CSS = "/* CSS d'animation non détecté. Créez un style de base. */";
      const JS = "// JS d'animation non détecté.";
      return `Vous êtes "Studio AI", un développeur expert. Transformez le code suivant en une page web complète. **Instructions :** 1. Répondez par un court message de confirmation. 2. Immédiatement après, générez trois blocs XML : <file name="index.html">, <file name="style.css">, et <file name="script.js">. 3. Le HTML doit être complet, lier style.css et script.js (avec defer). 4. Le <body> doit contenir le HTML fourni. --- HTML: \`\`\`html\n${HTML}\n\`\`\` --- CSS: \`\`\`css\n${CSS}\n\`\`\` --- JS: \`\`\`javascript\n${JS}\n\`\`\` --- Attendez les prochaines instructions.`;
  };

  const handleInitiateAIStudio = async () => {
    if (!result) return;
    setAiStudioInitiated(true);
    setIsAiResponding(true);
    setAiMessage("");
    setAiGeneratedFiles({ html: '', css: '', js: '' });
  
    const GEMINI_API_KEY = "AIzaSyDQRPehpA6TVODVOcofx7NCQr7vhTnk6zM"; // N'oubliez pas de gérer cette clé de manière sécurisée
    const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent";
  
    const requestBody = {
      contents: [
        {
          parts: [
            {
              text: buildInitialPromptForAI()
            }
          ]
        }
      ]
    };
  
    try {
      const response = await fetch(`${API_URL}?key=${GEMINI_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(requestBody)
      });
  
      if (!response.ok) {
        const errorBody = await response.json();
        throw new Error(`Erreur de l'API: ${response.status} ${response.statusText} - ${JSON.stringify(errorBody)}`);
      }
  
      const data = await response.json();
      
      // Assurez-vous que la réponse contient les données attendues
      if (!data.candidates || !data.candidates[0].content || !data.candidates[0].content.parts[0].text) {
        throw new Error("Format de réponse de l'API inattendu.");
      }
      
      const fullResponseText = data.candidates[0].content.parts[0].text;
  
      const conversationalPart = fullResponseText.split(/<file name="/)[0];
      setAiMessage(conversationalPart.trim());
  
      const htmlMatch = fullResponseText.match(/<file name="index.html">([\s\S]*?)<\/file>/);
      const cssMatch = fullResponseText.match(/<file name="style.css">([\s\S]*?)<\/file>/);
      const jsMatch = fullResponseText.match(/<file name="script.js">([\s\S]*?)<\/file>/);
  
      setAiGeneratedFiles({
        html: htmlMatch ? htmlMatch[1].trim() : "<!-- Fichier HTML non généré -->",
        css: cssMatch ? cssMatch[1].trim() : "/* Fichier CSS non généré */",
        js: jsMatch ? jsMatch[1].trim() : "// Fichier JS non généré"
      });
  
    } catch (err) {
      console.error("Erreur Gemini (fetch):", err);
      const errorMessage = err instanceof Error ? err.message : "Une erreur inconnue est survenue.";
      setAiMessage(`Désolé, une erreur est survenue. Vérifiez la clé API et la console. Détails : ${errorMessage}`);
    } finally {
      setIsAiResponding(false);
    }
  };

  const createAiPreviewSrcDoc = () => {
    if (!aiGeneratedFiles.html) return "";
    return aiGeneratedFiles.html
      .replace('</head>', `<style>${aiGeneratedFiles.css}</style></head>`)
      .replace('</body>', `<script>${aiGeneratedFiles.js}</script></body>`);
  };

  return (
    <div className="min-h-screen bg-white overflow-hidden p-4 sm:p-8">
      <header className="max-w-4xl mx-auto flex justify-between items-center mb-12">
        <svg className="h-[20px] w-[20px]" width="36" height="36" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" fill="#111"><rect x="0" y="0" width="32" height="32" rx="10" /></svg>
        <HeaderAction />
      </header>

      <div className="max-w-4xl mx-auto p-6 sm:p-10 pb-40">
        <div className="text-center mb-10">
          <CircularText size={140} />
          <h1 className={`${bodoni.className} text-5xl sm:text-7xl md:text-8xl leading-[1.05] text-black mb-4`}>Clone your favorite website design.</h1>
          <p className="text-lg text-gray-600 max-w-xl mx-auto">Paste a URL, launch the process, and instantly get a pixel-perfect replica of any website&apos;s design.</p>
        </div>

        <div className="h-[45px] w-[90%] sm:w-[400px] ring-5 ring-[#eee] rounded-[12px] flex items-center p-1 mx-auto mb-4">
            <div className="h-full w-full bg-[#fff] ring-4 ring-[#FAFAFA] rounded-[12px] flex items-center p-1 ">
                <div className="p-2"><Globe size={20} className="text-black" /></div>
                <input type="text" placeholder="https://example.com" value={url} onChange={(e) => setUrl(e.target.value)} onFocus={onInputFocus} className={`flex-grow h-full bg-transparent text-black focus:outline-none focus:ring-0 placeholder-[#888] text-sm`} />
                <button onClick={handleAnalyzeClick} disabled={loading} className="h-[35px] w-[35px] bg-[#111] rounded-[8px] flex items-center justify-center flex-shrink-0 transition-opacity disabled:opacity-70 disabled:cursor-not-allowed mr-1">
                    {loading ? <div className="bg-white rounded-[6px] w-4 h-4 animate-pulse" /> : <ArrowUp size={20} className="text-white" />}
                </button>
            </div>
        </div>
        
        {loading && <div className="text-center mt-4"><p className="text-gray-500">Analyse en cours...</p></div>}
        {error && <div className="text-center mt-4"><p className="text-red-500">{error}</p></div>}

        {!loading && !result && <LogoMarquee />}

        {result && (
          <div className="space-y-12 mt-12">
            <div>
              <h3 className="text-2xl font-bold text-black mb-4">UI preview (Full)</h3>
              <iframe title="UI preview" className="w-full h-96 border border-gray-200 rounded-xl bg-white" srcDoc={createOptimizedPreview()} sandbox="allow-scripts allow-same-origin" />
            </div>
            <div>
              <h3 className="text-2xl font-bold text-black mb-4">Animation-focused Preview (Reduced Code)</h3>
              <iframe title="Reduced UI preview" className="w-full h-96 border border-gray-200 rounded-xl bg-white" srcDoc={createReducedPreview()} sandbox="allow-scripts allow-same-origin" />
            </div>
            
            <div className="border-t-2 border-gray-100 pt-12">
              {!aiStudioInitiated ? (
                <div className="text-center">
                  <h2 className="text-3xl font-bold text-black mb-4">Prêt à construire ?</h2>
                  <Button size="lg" onClick={handleInitiateAIStudio} disabled={isAiResponding}>
                    <Bot className="mr-2 h-5 w-5" />
                    {isAiResponding ? "Initialisation..." : "Lancer le Studio AI"}
                  </Button>
                </div>
              ) : (
                <div>
                  <h2 className="text-3xl font-bold text-black mb-2 text-center">AI Builder Studio</h2>
                  <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
                      <div className="space-y-6">
                          <div className="border border-gray-200 rounded-xl p-4 h-96 flex flex-col bg-white">
                              <div className="flex-grow overflow-y-auto pr-2 space-y-4">
                                  <div className="flex items-start gap-3">
                                      <Avatar className="w-8 h-8"><AvatarFallback><Bot size={18}/></AvatarFallback></Avatar>
                                      <div className="max-w-xs md:max-w-sm rounded-2xl px-4 py-2 bg-gray-100 text-black rounded-bl-none">
                                          <p className="text-sm whitespace-pre-wrap">{aiMessage || (isAiResponding && "...")}</p>
                                      </div>
                                  </div>
                              </div>
                              <div className="mt-4 flex gap-2">
                                  <input type="text" placeholder="Discuter... (bientôt)" disabled className="flex-grow h-10 rounded-md border bg-gray-50 px-3 text-sm" />
                                  <Button disabled><Send size={18}/></Button>
                              </div>
                          </div>
                          <div className="border border-gray-200 rounded-xl h-96 flex flex-col bg-white">
                              <div className="flex-shrink-0 border-b p-2 flex items-center gap-2">
                                  <Button size="sm" variant={activeFile === 'html' ? 'secondary' : 'ghost'} onClick={() => setActiveFile('html')}>index.html</Button>
                                  <Button size="sm" variant={activeFile === 'css' ? 'secondary' : 'ghost'} onClick={() => setActiveFile('css')}>style.css</Button>
                                  <Button size="sm" variant={activeFile === 'js' ? 'secondary' : 'ghost'} onClick={() => setActiveFile('js')}>script.js</Button>
                              </div>
                              <pre className="flex-grow overflow-auto text-xs p-4 bg-gray-50/50"><code>{activeFile === 'html' ? aiGeneratedFiles.html : activeFile === 'css' ? aiGeneratedFiles.css : aiGeneratedFiles.js}</code></pre>
                          </div>
                      </div>
                      <div className="space-y-2">
                          <h3 className="text-lg font-bold text-black flex items-center gap-2"><Eye size={20}/> Live Preview de l'IA</h3>
                          <iframe title="AI Generated Preview" className="w-full h-[800px] border border-gray-200 rounded-xl bg-white" srcDoc={createAiPreviewSrcDoc()} sandbox="allow-scripts allow-same-origin" />
                      </div>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}
      </div>

      {result && (
        <div className="fixed bottom-0 left-0 right-0 p-4 flex justify-center">
            <div className="flex items-center gap-3">
                <div className="h-[40px] w-auto flex items-center rounded-[14px] bg-white shadow-md border border-[#e5e5e5]"><Button onClick={handleCopyPrompt} variant="ghost" className="h-[38px] rounded-[12px] text-sm font-medium px-4"><Copy className="mr-2 h-4 w-4" />Copy Prompt</Button></div>
                <div className="h-[40px] w-auto flex items-center rounded-[14px] bg-white shadow-md border border-[#e5e5e5]"><Button onClick={handleDownloadPrompt} variant="ghost" className="h-[38px] rounded-[12px] text-sm font-medium px-4"><Download className="mr-2 h-4 w-4" />Download Prompt</Button></div>
                <div className="h-[40px] w-auto flex items-center rounded-[14px] bg-white shadow-md border border-[#e5e5e5]"><Button onClick={() => setShowExportModal(true)} variant="ghost" className="h-[38px] rounded-[12px] text-sm font-medium px-4"><Download className="mr-2 h-4 w-4" />Download Original</Button></div>
                {copyStatus?.id === "prompt" && (<span className="text-sm text-green-600 bg-green-50 px-3 py-1 rounded-md">{copyStatus.message}</span>)}
            </div>
        </div>
      )}

      <Dialog open={showExportModal} onOpenChange={setShowExportModal}>
        <DialogContent className="sm:max-w-3xl">
          <DialogHeader>
            <DialogTitle>Export code</DialogTitle>
            <DialogDescription>Select a framework and preview the single-file export. Then download or copy it.</DialogDescription>
          </DialogHeader>
          <div className="grid gap-4">
            <div className="grid grid-cols-1 sm:grid-cols-3 gap-3">
              <div className="space-y-2 sm:col-span-2">
                <Label htmlFor="framework">Framework</Label>
                <select id="framework" className="w-full h-10 rounded-md border border-gray-200 bg-white px-3 text-sm" value={selectedFramework} onChange={(e) => setSelectedFramework(e.target.value as FrameworkKey)}>
                  {Object.entries(frameworkLabel).map(([key, label]) => (<option key={key} value={key}>{label}</option>))}
                </select>
              </div>
              <div className="space-y-2">
                <Label className="inline-flex items-center justify-between w-full"><span>View code</span><Switch checked={showCodePreview} onCheckedChange={setShowCodePreview} /></Label>
                <input readOnly value={generatedFilename} className="w-full h-10 rounded-md border border-gray-200 bg-gray-50 px-3 text-xs" />
              </div>
            </div>
            {showCodePreview && (
              <div className="rounded-lg border bg-[#0b0c10] border-gray-800 overflow-hidden">
                <div className="px-3 py-2 text-xs text-gray-300 bg-[#0f1117] border-b border-gray-800 flex justify-between">
                  <span>{generatedFilename}</span>
                  <span className="text-gray-500">readonly preview</span>
                </div>
                <pre className="max-h-[420px] overflow-auto text-xs leading-5 p-4 text-gray-100"><code>{generatedCode}</code></pre>
              </div>
            )}
          </div>
          <DialogFooter className="gap-2">
            <Button variant="secondary" onClick={() => copyToClipboard(generatedCode, "export-code")} disabled={!generatedCode}><Copy className="mr-2 h-4 w-4" />Copy code</Button>
            <Button onClick={() => { if (!generatedCode || !generatedFilename) return; const mime = "text/plain"; createDownloadLink(generatedCode, generatedFilename.replaceAll("/", "_"), mime); }} disabled={!generatedCode}><Download className="mr-2 h-4 w-4" />Download file</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  )
}